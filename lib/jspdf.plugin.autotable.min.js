"use strict";

function _classCallCheck(a, b) { if (!(a instanceof b)) throw new TypeError("Cannot call a class as a function") }! function(a) {
    function b(a, b, c) { a && "object" == typeof a || console.error("The headers should be an object or array, is: " + typeof a), b && "object" == typeof b || console.error("The data should be an object or array, is: " + typeof b), c && "object" != typeof c && console.error("The data should be an object or array, is: " + typeof b), Array.prototype.forEach || console.error("The current browser does not support Array.prototype.forEach which is required for jsPDF-AutoTable. You can try polyfilling it by including this script https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Polyfill") }

    function c(a) {
        var b = o(x(), a);
        "undefined" != typeof b.extendWidth && (b.tableWidth = b.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), "undefined" != typeof b.margins && ("undefined" == typeof b.margin && (b.margin = b.margins), console.error("Use of deprecated option: margins, use margin instead.")), [
            ["padding", "cellPadding"],
            ["lineHeight", "rowHeight"], "fontSize", "overflow"
        ].forEach(function(a) {
            var c = "string" == typeof a ? a : a[0],
                d = "string" == typeof a ? a : a[1];
            "undefined" != typeof b[c] && ("undefined" == typeof b.styles[d] && (b.styles[d] = b[c]), console.error("Use of deprecated option: " + c + ", use the style " + d + " instead."))
        });
        var c = b.margin;
        return b.margin = {}, "number" == typeof c.horizontal && (c.right = c.horizontal, c.left = c.horizontal), "number" == typeof c.vertical && (c.top = c.vertical, c.bottom = c.vertical), ["top", "right", "bottom", "left"].forEach(function(a, d) {
            if ("number" == typeof c) b.margin[a] = c;
            else {
                var e = Array.isArray(c) ? d : a;
                b.margin[a] = "number" == typeof c[e] ? c[e] : 40
            }
        }), b
    }

    function d(a, b) {
        t = new Table, t.x = r.margin.left;
        var c = /\r\n|\r|\n/g,
            d = new Row(a);
        d.index = -1;
        var e = o(v, w[r.theme].table, w[r.theme].header);
        d.styles = o(e, r.styles, r.headerStyles), a.forEach(function(a, b) {
            "object" == typeof a && (b = "undefined" != typeof a.dataKey ? a.dataKey : a.key), "undefined" != typeof a.width && console.error("Use of deprecated option: column.width, use column.styles.columnWidth instead.");
            var e = new Column(b);
            e.styles = r.columnStyles[e.dataKey] || {}, t.columns.push(e);
            var f = new Cell;
            f.raw = "object" == typeof a ? a.title : a, f.styles = d.styles, f.text = "" + f.raw, f.contentWidth = 2 * f.styles.cellPadding + n(f.text, f.styles), f.text = f.text.split(c), d.cells[b] = f, r.createdHeaderCell(f, { column: e, row: d, settings: r })
        }), t.headerRow = d, b.forEach(function(a, b) {
            var d = new Row(a),
                e = b % 2 === 0,
                f = o(v, w[r.theme].table, e ? w[r.theme].alternateRow : {}),
                g = o(r.styles, r.bodyStyles, e ? r.alternateRowStyles : {});
            d.styles = o(f, g), d.index = b, t.columns.forEach(function(b) {
                var e = new Cell;
                e.raw = a[b.dataKey], e.styles = o(d.styles, b.styles), e.text = "undefined" != typeof e.raw ? "" + e.raw : "", d.cells[b.dataKey] = e, r.createdCell(e, l({ column: b, row: d })), e.contentWidth = 2 * e.styles.cellPadding + n(e.text, e.styles), e.text = e.text.split(c)
            }), t.rows.push(d)
        })
    }

    function e() {
        var a = 0;
        t.columns.forEach(function(b) {
            b.contentWidth = t.headerRow.cells[b.dataKey].contentWidth, t.rows.forEach(function(a) {
                var c = a.cells[b.dataKey].contentWidth;
                c > b.contentWidth && (b.contentWidth = c)
            }), b.width = b.contentWidth, a += b.contentWidth
        }), t.contentWidth = a;
        var b = p.internal.pageSize.width - r.margin.left - r.margin.right,
            c = b;
        "number" == typeof r.tableWidth ? c = r.tableWidth : "wrap" === r.tableWidth && (c = t.contentWidth), t.width = b > c ? c : b;
        var d = [],
            e = 0,
            g = t.width / t.columns.length,
            h = 0;
        t.columns.forEach(function(a) { var b = o(v, w[r.theme].table, r.styles, a.styles); "wrap" === b.columnWidth ? a.width = a.contentWidth : "number" == typeof b.columnWidth ? a.width = b.columnWidth : ("auto" === b.columnWidth, 0 || (a.contentWidth <= g && t.contentWidth > t.width ? a.width = a.contentWidth : (d.push(a), e += a.contentWidth, a.width = 0))), h += a.width }), f(d, h, e, g), t.height = 0;
        var i = t.rows.concat(t.headerRow);
        i.forEach(function(a, b) {
            var c = 0,
                d = t.x;
            t.columns.forEach(function(b) {
                var e = a.cells[b.dataKey];
                b.x = d, k(e.styles);
                var f = b.width - 2 * e.styles.cellPadding;
                "linebreak" === e.styles.overflow ? e.text = p.splitTextToSize(e.text, f + 1, { fontSize: e.styles.fontSize }) : "ellipsize" === e.styles.overflow ? e.text = m(e.text, f, e.styles) : "visible" === e.styles.overflow || ("hidden" === e.styles.overflow ? e.text = m(e.text, f, e.styles, "") : "function" == typeof e.styles.overflow ? e.text = e.styles.overflow(e.text, f) : console.error("Unrecognized overflow type: " + e.styles.overflow));
                var g = Array.isArray(e.text) ? e.text.length - 1 : 0;
                g > c && (c = g), d += b.width
            }), a.heightStyle = a.styles.rowHeight, a.height = a.heightStyle + c * a.styles.fontSize * u, t.height += a.height
        })
    }

    function f(a, b, c, d) {
        for (var e = t.width - b - c, g = 0; g < a.length; g++) {
            var h = a[g],
                i = h.contentWidth / c,
                j = h.contentWidth + e * i < d;
            if (0 > e && j) { a.splice(g, 1), c -= h.contentWidth, h.width = d, b += h.width, f(a, b, c, d); break }
            h.width = h.contentWidth + e * i
        }
    }

    function g() {
        t.rows.forEach(function(a, b) {
            if (i(a.height)) { h() }
            a.y = q.y, r.drawRow(a, l({ row: a })) !== !1 && j(a, r.drawCell)
        })
    }

    function h() { r.afterPageContent(l()), p.addPage(), s++, q = { x: r.margin.left, y: r.margin.top }, r.beforePageContent(l()), r.drawHeaderRow(t.headerRow, l({ row: t.headerRow })) !== !1 && j(t.headerRow, r.drawHeaderCell) }

    function i(a) { var b = q.y + a + r.margin.bottom; return b >= p.internal.pageSize.height }

    function j(a, b) {
        for (var c = 0; c < t.columns.length; c++) {
            var d = t.columns[c],
                e = a.cells[d.dataKey];
            if (e) {
                k(e.styles), e.x = d.x, e.y = q.y, e.height = a.height, e.width = d.width, "top" === e.styles.valign ? e.textPos.y = q.y + e.styles.cellPadding : "bottom" === e.styles.valign ? e.textPos.y = q.y + a.height - e.styles.cellPadding : e.textPos.y = q.y + a.height / 2, "right" === e.styles.halign ? e.textPos.x = e.x + e.width - e.styles.cellPadding : "center" === e.styles.halign ? e.textPos.x = e.x + e.width / 2 : e.textPos.x = e.x + e.styles.cellPadding;
                var f = l({ column: d, row: a });
                b(e, f) !== !1 && (p.rect(e.x, e.y, e.width, e.height, e.styles.fillStyle), p.autoTableText(e.text, e.textPos.x, e.textPos.y, { halign: e.styles.halign, valign: e.styles.valign }))
            }
        }
        q.y += a.height
    }

    function k(a) {
        var b = [{ func: p.setFillColor, value: a.fillColor }, { func: p.setTextColor, value: a.textColor }, { func: p.setFontStyle, value: a.fontStyle }, { func: p.setDrawColor, value: a.lineColor }, { func: p.setLineWidth, value: a.lineWidth }, { func: p.setFont, value: a.font }, { func: p.setFontSize, value: a.fontSize }];
        b.forEach(function(a) { "undefined" != typeof a.value && (a.value.constructor === Array ? a.func.apply(this, a.value) : a.func(a.value)) })
    }

    function l(a) { a = a || {}; var b = { pageCount: s, settings: r, table: t, cursor: q }; for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]); return b }

    function m(a, b, c, d) { if (d = "undefined" != typeof d ? d : "...", Array.isArray(a)) return a.forEach(function(e, f) { a[f] = m(e, b, c, d) }), a; if (b >= n(a, c)) return a; for (; b < n(a + d, c) && !(a.length < 2);) a = a.substring(0, a.length - 1); return a.trim() + d }

    function n(a, b) { k(b); var c = p.getStringUnitWidth(a); return c * b.fontSize }

    function o(a) { var b, c = {}; for (b in a) a.hasOwnProperty(b) && (c[b] = a[b]); for (var d = 1; d < arguments.length; d++) { var e = arguments[d]; for (b in e) e.hasOwnProperty(b) && ("object" != typeof e[b] || Array.isArray(e[b]) ? c[b] = e[b] : c[b] = e[b]) } return c }
    var p, q, r, s, t, u = 1.15,
        v = { cellPadding: 5, fontSize: 10, font: "helvetica", lineColor: 200, lineWidth: .1, fontStyle: "normal", overflow: "ellipsize", fillColor: 255, textColor: 20, halign: "left", valign: "top", fillStyle: "F", rowHeight: 20, columnWidth: "auto" },
        w = { striped: { table: { fillColor: 255, textColor: 80, fontStyle: "normal", fillStyle: "F" }, header: { textColor: 255, fillColor: [41, 128, 185], rowHeight: 23, fontStyle: "bold" }, body: {}, alternateRow: { fillColor: 245 } }, grid: { table: { fillColor: 255, textColor: 80, fontStyle: "normal", lineWidth: .1, fillStyle: "DF" }, header: { textColor: 255, fillColor: [26, 188, 156], rowHeight: 23, fillStyle: "F", fontStyle: "bold" }, body: {}, alternateRow: {} }, plain: { header: { fontStyle: "bold" } } },
        x = function() { return { theme: "striped", styles: {}, headerStyles: {}, bodyStyles: {}, alternateRowStyles: {}, columnStyles: {}, startY: !1, margin: 40, pageBreak: "auto", tableWidth: "auto", createdHeaderCell: function(a, b) {}, createdCell: function(a, b) {}, drawHeaderRow: function(a, b) {}, drawRow: function(a, b) {}, drawHeaderCell: function(a, b) {}, drawCell: function(a, b) {}, beforePageContent: function(a) {}, afterPageContent: function(a) {} } };
    a.autoTable = function(a, f, h) {
        b(a, f, h), p = this, r = c(h || {}), s = 1, q = { y: r.startY === !1 ? r.margin.top : r.startY };
        var i = { textColor: 30, fontSize: p.internal.getFontSize(), fontStyle: p.internal.getFont().fontStyle };
        d(a, f), e();
        var m = t.rows[0] && "auto" === r.pageBreak ? t.rows[0].height : 0,
            n = r.startY + r.margin.bottom + t.headerRow.height + m;
        return "avoid" === r.pageBreak && (n += t.height), ("always" === r.pageBreak && r.startY !== !1 || r.startY !== !1 && n > p.internal.pageSize.height) && (p.addPage(), q.y = r.margin.top), k(i), r.beforePageContent(l()), r.drawHeaderRow(t.headerRow, l({ row: t.headerRow })) !== !1 && j(t.headerRow, r.drawHeaderCell), k(i), g(), r.afterPageContent(l()), k(i), this
    }, a.autoTableEndPosY = function() { return "undefined" == typeof q || "undefined" == typeof q.y ? 0 : q.y }, a.autoTableHtmlToJson = function(a) {
        var b, c, d, e, f = [],
            g = [],
            h = a.rows[0];
        for (d = 0; d < h.cells.length; d++) g.push("undefined" != typeof h.cells[d] ? h.cells[d].textContent : "");
        for (d = 1; d < a.rows.length; d++) {
            for (b = a.rows[d], c = [], e = 0; e < h.cells.length; e++) c.push("undefined" != typeof b.cells[e] ? b.cells[e].textContent : "");
            f.push(c)
        }
        return { columns: g, data: f, rows: f }
    }, a.autoTableText = function(a, b, c, d) {
        ("number" != typeof b || "number" != typeof c) && console.error("The x and y parameters are required. Missing for the text: ", a);
        var e = p.internal.getFontSize() / p.internal.scaleFactor,
            f = u,
            g = /\r\n|\r|\n/g,
            h = null,
            i = 1;
        if (("middle" === d.valign || "bottom" === d.valign || "center" === d.halign || "right" === d.halign) && (h = "string" == typeof a ? a.split(g) : a, i = h.length || 1), c += e * (2 - f), "middle" === d.valign ? c -= i / 2 * e : "bottom" === d.valign && (c -= i * e), "center" === d.halign || "right" === d.halign) {
            var j = e;
            if ("center" === d.halign && (j *= .5), i >= 1) { for (var k = 0; k < h.length; k++) p.text(h[k], b - p.getStringUnitWidth(h[k]) * j, c), c += e; return p }
            b -= p.getStringUnitWidth(a) * j
        }
        return p.text(a, b, c), p
    }
}(jsPDF.API);
var Table = function a() { _classCallCheck(this, a), this.height = 0, this.width = 0, this.x = 0, this.y = 0, this.contentWidth = 0, this.rows = [], this.columns = [], this.headerRow = null, this.settings = {} },
    Row = function b(a) { _classCallCheck(this, b), this.raw = a || {}, this.index = 0, this.styles = {}, this.cells = {}, this.height = 0, this.y = 0 },
    Cell = function c(a) { _classCallCheck(this, c), this.raw = a, this.styles = {}, this.text = "", this.contentWidth = 0, this.textPos = {}, this.height = 0, this.width = 0, this.x = 0, this.y = 0 },
    Column = function d(a) { _classCallCheck(this, d), this.dataKey = a, this.options = {}, this.styles = {}, this.contentWidth = 0, this.width = 0, this.x = 0 };